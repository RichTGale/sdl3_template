<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SDL-gsoc2010_shaped_windows</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">:root {
color-scheme: dark light; 
}
body {
background-color: white;
padding: 2vw;
color: #333;
max-width: 1200px;
margin: 0 auto;
font-size: 16px;
line-height: 1.5;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans",
Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
overflow-wrap: break-word;
}
a {
color: #0969da;

}
a:visited {
color: #064998;
}
h1 {
border-bottom: 2px solid #efefef;
}
h2 {
border-bottom: 1px solid #efefef;
}
p {
max-width: 85ch;
}
li {
max-width: 85ch;
}
div.sourceCode {
background-color: #f6f8fa;
max-width: 100%;
padding: 16px;
}
code {
background-color: #f6f8fa;
padding: 0px;
font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas,
"Liberation Mono", monospace;
}
table {
border: 1px solid #808080;
border-collapse: collapse;
}
td {
border: 1px solid #808080;
padding: 5px;
}
tr:nth-child(even) {
background-color: #f6f8fa;
}
.wikitopbanner {
display: flex;
justify-content: space-between;
align-items: center;
background-color: #efefef;
padding: 10px;
margin-bottom: 10px;
width: auto;
}
.wikibottombanner {
background-color: #efefef;
padding: 10px;
margin-top: 10px;
width: auto;
}
.alertBox {
background-color: #f8d7da;
border: 1px solid #f5c6cb;
max-width: 60%;
padding: 10;
margin: auto;
}
.anchorImage {
visibility: hidden;
padding-left: 0.2em;
color: #fff;
}
.anchorText:hover .anchorImage {
visibility: visible;
}
hr {
display: block;
height: 1px;
border: 0;
border-top: 1px solid #efefef;
margin: 1em 0;
padding: 0;
}

@media (prefers-color-scheme: dark) {
body {
color: #e6edf3;
background-color: #0d1117;
}
h1 {
border-color: rgba(48, 54, 61, 0.7);
}
h2 {
border-color: rgba(48, 54, 61, 0.7);
}
hr {
border-color: rgba(48, 54, 61, 0.7);
}
div.sourceCode {
background-color: #161b22;
}
code {
background-color: #161b22;
}
a {
color: #4493f8;
}
a:visited {
color: #2f66ad;
}
table {
border-color: rgba(48, 54, 61, 0.7);
}
td {
border-color: rgba(48, 54, 61, 0.7);
}
tr:nth-child(even) {
background-color: #161b22;
}
.wikitopbanner {
background-color: #263040;
}
.wikibottombanner {
background-color: #263040;
}
.anchorText:hover .anchorImage {
filter: invert(100%);
}
}
@media print {
body {
font-size: 12px;
}
table {
font-size: inherit;
}
a:visited {
color: #0969da;
}
.wikitopbanner,
.anchorText,
.wikibottombanner {
display: none;
}
}
</style>
  <style type="text/css"> code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
{ position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
{ content: attr(title);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; pointer-events: all; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
@media (prefers-color-scheme: dark) {
code span.al { color: #95da4c; font-weight: bold; } 
code span.an { color: #3f8058; } 
code span.at { color: #2980b9; } 
code span.bn { color: #f67400; } 
code span.bu { color: #7f8c8d; } 
code span.ch { color: #3daee9; } 
code span.co { color: #7a7c7d; } 
code span.cv { color: #7f8c8d; } 
code span.cn { color: #27aeae; font-weight: bold; } 
code span.cf { color: #fdbc4b; font-weight: bold; } 
code span.dt { color: #2980b9; } 
code span.dv { color: #f67400; } 
code span.do { color: #a43340; } 
code span.er { color: #da4453; } 
code span.ex { color: #0099ff; font-weight: bold; } 
code span.fl { color: #f67400; } 
code span.fu { color: #8e44ad; } 
code span.im { color: #27ae60; } 
code span.in { color: #c45b00; } 
code span.kw { color: #cfcfc2; font-weight: bold; } 
code span.op { color: #cfcfc2; } 
code span.ot { color: #27ae60; } 
code span.pp { color: #27ae60; } 
code span.sc { color: #3daee9; } 
code span.ss { color: #da4453; } 
code span.st { color: #f44f4f; } 
code span.va { color: #27aeae; } 
code span.vs { color: #da4453; } 
code span.wa { color: #da4453; } 
}</style>
</head>
<body>
<p>This is a scratch pad for the Shaped Windows Google Summer of Code
2010 project, by Eli Gottlieb</p>
<p>The code is available here: --( <a href="http://hg.libsdl.org/SDL/gsoc2010_shaped_windows">http://hg.libsdl.org/SDL/gsoc2010_shaped_windows</a>
)--</p>
<h2 id="status">Status</h2>
<p>GSoC code submitted and merged with 1.3 branch.</p>
<h2 id="documentation">Documentation</h2>
<p>The actual API itself is simple. SDL_CreateShapedWindow() returns an
SDL_Window with the correct attributes and the capability to be shaped.
From there, the user can either check if any particular window is a
shaped window via a predicate function, or they can set the shape of a
window by passing a shape surface with an alpha channel into
SDL_SetWindowShape(). This function also accepts a structure of mode
parameters, which are currently used to specify the cutoff value for the
shape&#39;s alpha channel. At or above that cutoff value, a pixel is visible
in the shape. Below that, it&#39;s not part of the shape.</p>
<h2 id="notes">Notes</h2>
<h3 id="compiling_and_running_test_program">Compiling and Running Test
Program</h3>
<h4 id="linux">Linux</h4>
<ul>
<li>obtain repository: hg pull; hg update</li>
<li>compile SDL: ./configure; make; sudo make install</li>
<li>compile test: cd test; ./configure; make</li>
<li>run test: ./testeyes shapes/file.bmp</li>
</ul>
<h4 id="osx_macports">OSX (MacPorts)</h4>
<ul>
<li>obtain/install MacPort
(https://trac.macports.org/wiki/InstallingMacPorts)</li>
<li>obtain repository: hg pull; hg update</li>
<li>compile SDL: ./autogen.sh; ./configure; make; sudo make install</li>
<li>compile test: cd test; ./configure; make</li>
<li>run test: ./testeyes shapes/file.bmp</li>
</ul>
<h4 id="win32_vs">Win32 (VS)</h4>
<ul>
<li>open solution file and build</li>
</ul>
<h3 id="pre_processing">Pre-Processing</h3>
<p>Possible pre-processing pipelines:</p>
<p>input shape bitmap stored as surface or texture -(1)-&gt; SDL
rendering-from-texture function -(2)-&gt; possible region-queue or mask
bitmap -(3)-&gt; render target associated with window shape is presented
-(4)-&gt; driver-specific shape-setting functions</p>
<p><code>1. Two-valued alpha channel determines shape.</code><br />
<code>1. possibly optional, some drivers&#39; internal representations of shapes may be close enough to be used in place of an abstract data structure</code><br />
<code>1. user signals that they are finished drawing the window shape</code><br />
<code>1. driver-independent abstract data structure such as mask or region queue is converted to driver-specific data and the window shape is actually changed.</code></p>
<h3 id="x11">X11</h3>
<ul>
<li>Set via the &quot;Shape Extension&quot; <a href="http://en.wikipedia.org/wiki/Shape_extension">http://en.wikipedia.org/wiki/Shape_extension</a></li>
<li>Documentation with C API <a href="http://www.xfree86.org/current/shapelib.html">http://www.xfree86.org/current/shapelib.html</a></li>
<li>If extension is missing from X, add Load &quot;extmod&quot; to the &quot;Modules&quot;
section of the xorg.conf file (=makes for a good error message on shape
extension detection).</li>
</ul>
<p>Currently figuring out how to link to the shape extension.</p>
<h3 id="windows">Windows</h3>
<h4 id="regions">Regions</h4>
<p>Most commonly used is code that essentially sets a &quot;region&quot; which
defines which pixels are shown and which are not. Most algorithms uses
the Win32 region functions to compose this shape which is simple but
works. In any case, the input to this process is a binarized (1bit)
image. Note that you don&#39;t get any &quot;blending&quot; on the edges with this
approach.</p>
<p>Here some other sample code:</p>
<ul>
<li>Sets shape by generating regions: <a href="http://comrade.ownz.com/docs/shapewnd.html">http://comrade.ownz.com/docs/shapewnd.html</a></li>
<li>Shape of Form by using background key color: <a href="http://msdn.microsoft.com/en-us/beginner/cc963986.aspx">http://msdn.microsoft.com/en-us/beginner/cc963986.aspx</a></li>
<li>Setting per-Window alpha: <a href="http://msdn.microsoft.com/en-us/beginner/cc963986.aspx">http://msdn.microsoft.com/en-us/beginner/cc963986.aspx</a></li>
<li>Form app in .Net calling the Win32 Api: <a href="http://www.codeproject.com/KB/miscctrl/AlphaForm.aspx">http://www.codeproject.com/KB/miscctrl/AlphaForm.aspx</a></li>
<li>Great summary with examples for all modes in Delphi: <a href="http://melander.dk/articles/alphasplash/">http://melander.dk/articles/alphasplash/</a></li>
</ul>
<h4 id="layered_window">Layered Window</h4>
<p>Now there is another way to provide transparency using an
alpha-bitmap in Windows. The API to be used is the UpdateLayeredWindow()
call:</p>
<ul>
<li>MSDN info: [<a href="http://msdn.microsoft.com/en-us/library/ms633556(VS.85">http://msdn.microsoft.com/en-us/library/ms633556(VS.85</a>).aspx
<a href="http://msdn.microsoft.com/en-us/library/ms633556%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms633556%28VS.85%29.aspx</a>]</li>
<li>Sample code: <a href="http://www.nuonsoft.com/blog/2009/05/27/how-to-use-updatelayeredwindow/">http://www.nuonsoft.com/blog/2009/05/27/how-to-use-updatelayeredwindow/</a></li>
<li>Sample code: Per Pixel Alpha Blend <a href="http://www.codeproject.com/kb/gdi/pxalphablend.aspx">http://www.codeproject.com/kb/gdi/pxalphablend.aspx</a></li>
</ul>
<p>Even with this approach a shape vector may still be important, to get
rid of clicks to the window - a window that is almost transparent (i.e.
alpha=1) seems to have no shape, but will still receive clicks on those
pixels. Note also, that the layered window API is not supported on WinCE
(but the shape API is).</p>
<h4 id="directx_onpaint">DirectX OnPaint</h4>
<p>The OnPaint functions makes the background transparent by drawing
black on it.</p>
<ul>
<li><a href="http://stackoverflow.com/questions/148275/how-do-i-draw-transparent-directx-content-in-a-transparent-window">http://stackoverflow.com/questions/148275/how-do-i-draw-transparent-directx-content-in-a-transparent-window</a></li>
</ul>
<h3 id="osx">OSX</h3>
<p>If Cocoa also uses also a shape, it may be good to break out a common
&quot;2D shape calculation&quot; algorithm that applies to both architectures.</p>
<h3 id="shape_regions">Shape Regions</h3>
<p>Note that a shape structure made out of regions has a list of 2D
points defining a polygon AND a add/delete flag. For example a doughnut
is made of two circle regions, one added and one deleted.</p>
</body>
</html>
