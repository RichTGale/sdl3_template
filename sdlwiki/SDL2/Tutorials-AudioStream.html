<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Tutorials-AudioStream</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  <style type="text/css">:root {
color-scheme: dark light; 
}
body {
background-color: white;
padding: 2vw;
color: #333;
max-width: 1200px;
margin: 0 auto;
font-size: 16px;
line-height: 1.5;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans",
Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
overflow-wrap: break-word;
}
a {
color: #0969da;

}
a:visited {
color: #064998;
}
h1 {
border-bottom: 2px solid #efefef;
}
h2 {
border-bottom: 1px solid #efefef;
}
p {
max-width: 85ch;
}
li {
max-width: 85ch;
}
div.sourceCode {
background-color: #f6f8fa;
max-width: 100%;
padding: 16px;
}
code {
background-color: #f6f8fa;
padding: 0px;
font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas,
"Liberation Mono", monospace;
}
table {
border: 1px solid #808080;
border-collapse: collapse;
}
td {
border: 1px solid #808080;
padding: 5px;
}
tr:nth-child(even) {
background-color: #f6f8fa;
}
.wikitopbanner {
display: flex;
justify-content: space-between;
align-items: center;
background-color: #efefef;
padding: 10px;
margin-bottom: 10px;
width: auto;
}
.wikibottombanner {
background-color: #efefef;
padding: 10px;
margin-top: 10px;
width: auto;
}
.alertBox {
background-color: #f8d7da;
border: 1px solid #f5c6cb;
max-width: 60%;
padding: 10;
margin: auto;
}
.anchorImage {
visibility: hidden;
padding-left: 0.2em;
color: #fff;
}
.anchorText:hover .anchorImage {
visibility: visible;
}
hr {
display: block;
height: 1px;
border: 0;
border-top: 1px solid #efefef;
margin: 1em 0;
padding: 0;
}

@media (prefers-color-scheme: dark) {
body {
color: #e6edf3;
background-color: #0d1117;
}
h1 {
border-color: rgba(48, 54, 61, 0.7);
}
h2 {
border-color: rgba(48, 54, 61, 0.7);
}
hr {
border-color: rgba(48, 54, 61, 0.7);
}
div.sourceCode {
background-color: #161b22;
}
code {
background-color: #161b22;
}
a {
color: #4493f8;
}
a:visited {
color: #2f66ad;
}
table {
border-color: rgba(48, 54, 61, 0.7);
}
td {
border-color: rgba(48, 54, 61, 0.7);
}
tr:nth-child(even) {
background-color: #161b22;
}
.wikitopbanner {
background-color: #263040;
}
.wikibottombanner {
background-color: #263040;
}
.anchorText:hover .anchorImage {
filter: invert(100%);
}
}
@media print {
body {
font-size: 12px;
}
table {
font-size: inherit;
}
a:visited {
color: #0969da;
}
.wikitopbanner,
.anchorText,
.wikibottombanner {
display: none;
}
}
</style>
  <style type="text/css"> code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
{ position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
{ content: attr(title);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; pointer-events: all; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
@media (prefers-color-scheme: dark) {
code span.al { color: #95da4c; font-weight: bold; } 
code span.an { color: #3f8058; } 
code span.at { color: #2980b9; } 
code span.bn { color: #f67400; } 
code span.bu { color: #7f8c8d; } 
code span.ch { color: #3daee9; } 
code span.co { color: #7a7c7d; } 
code span.cv { color: #7f8c8d; } 
code span.cn { color: #27aeae; font-weight: bold; } 
code span.cf { color: #fdbc4b; font-weight: bold; } 
code span.dt { color: #2980b9; } 
code span.dv { color: #f67400; } 
code span.do { color: #a43340; } 
code span.er { color: #da4453; } 
code span.ex { color: #0099ff; font-weight: bold; } 
code span.fl { color: #f67400; } 
code span.fu { color: #8e44ad; } 
code span.im { color: #27ae60; } 
code span.in { color: #c45b00; } 
code span.kw { color: #cfcfc2; font-weight: bold; } 
code span.op { color: #cfcfc2; } 
code span.ot { color: #27ae60; } 
code span.pp { color: #27ae60; } 
code span.sc { color: #3daee9; } 
code span.ss { color: #da4453; } 
code span.st { color: #f44f4f; } 
code span.va { color: #27aeae; } 
code span.vs { color: #da4453; } 
code span.wa { color: #da4453; } 
}</style>
</head>
<body>
<h1 id="using_sdl_audiostream">Using SDL_AudioStream</h1>
<p>From the dawn of time, until SDL 2.0.6, there was only one way to
convert audio through SDL: By using the <a href="SDL_AudioCVT.html" title="wikilink">SDL_AudioCVT</a> structure.</p>
<p>It&#39;s a usable API, for various needs, but it has a few problems:</p>
<ul>
<li>It&#39;s hard to understand how to use.</li>
<li>It can&#39;t carry any dynamic state; there&#39;s no API to &quot;free&quot; a
structure, so it can&#39;t allocate memory, or do special things for various
converters. In 2.0.6, it even commandeers a pointer in the struct it
hopes you aren&#39;t using, just to give it space for a few more bits of
internal state information. This also leads to some other inefficient
tapdances to wedge functionality into it.</li>
<li>The existing structure is extremely rigid, expecting certain fields
to be set by the app and certain fields to be set by SDL, and there is
no room for expansion. Did I mention we steal a pointer field?</li>
<li>Perhaps most importantly: it can&#39;t resample data in chunks. You have
to give it all the data it expects in one shot, or you&#39;ll get gaps and
skips in your audio output.</li>
</ul>
<p>We have a better API that SDL has been using internally for awhile
now, since it needs to bridge data between the app&#39;s audio callbacks and
the platform APIs that consume and produce data, and that data might be
coming and going at any size and format at inexact times. Not only does
this API have to convert and resample data on the fly, it needs to be
able to buffer it when one end produces data at a different rate than
the other is consuming it.</p>
<p>For SDL 2.0.7, we&#39;ve cleaned up these internal APIs and made them
available to apps. We call it <a href="SDL_AudioStream.html" title="wikilink">SDL_AudioStream</a>.</p>
<p>To avoid confusion: this is strictly an optional API, even if you use
SDL for audio playback or capture. SDL might use it behind the scenes if
it silently converts data between your callback and the platform, but
that isn&#39;t your concern. If you don&#39;t like callbacks and just wanted to
feed SDL audio data as you have more to give it, and let SDL figure it
out, you can do that too, but that&#39;s a different API (that&#39;s <a href="SDL_QueueAudio.html" title="wikilink">SDL_QueueAudio</a>() and
friends).</p>
<p>Here are some immediate uses for <a href="SDL_AudioStream.html" title="wikilink">SDL_AudioStream</a>:</p>
<ul>
<li>You want to decode an Ogg Vorbis file, and convert it to a specific
format for playback on the fly, but libvorbis only hands you 512 bytes
of uncompressed data at a time. You can push it through an <a href="SDL_AudioStream.html" title="wikilink">SDL_AudioStream</a> a drip
at a time, and pull converted data out of the other side, in a different
format, as needed.</li>
<li>You have a VoIP app, but you can&#39;t promise when audio packets will
arrive over the network, or how large those packets will be when they
do, or if you&#39;ll have to replace them with a chunk of silence when they
don&#39;t arrive at all...but you want to be able to produce a single
coherent stream of audio data, ready for playback.</li>
<li>You want to pull audio data from disk as fast as possible, stuff it
into something that will do the proper conversions, and dump the results
back to disk without having to worry about the details of the data as
it&#39;s passing through.</li>
<li>You want to write a mixer that only deals with a single specific
format and have it output to whatever else might need to eat that
data.</li>
<li>You have some procedurally-generated sound and want to produce more
when most of it has been consumed.</li>
<li>You have no interest in converting audio to a different format, but
you just want someone else to worry about storing it in an efficient,
queue-like data structure until you are ready to make use of it.</li>
</ul>
<p>Using <a href="SDL_AudioStream.html" title="wikilink">SDL_AudioStream</a> is pretty simple. First, you create
one. Let&#39;s say you want to produce mono data in Sint16 format at
22050Hz, for something that wants to consume stereo data in Float32
format at 48000Hz.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// You put data at Sint16/mono/22050Hz, you get back data at Float32/stereo/48000Hz</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>SDL_AudioStream <span class="op">*</span>stream <span class="op">=</span> SDL_NewAudioStream<span class="op">(</span>AUDIO_S16<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">22050</span><span class="op">,</span> AUDIO_F32<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">48000</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>stream <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Uhoh, stream failed to create: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> SDL_GetError<span class="op">());</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We are ready to use the stream!</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now all you have to do is feed your stream data!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Sint16 samples<span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> num_samples <span class="op">=</span> read_more_samples_from_disk<span class="op">(</span>samples<span class="op">);</span> <span class="co">// whatever.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">// you tell it the number of _bytes_, not samples, you&#39;re putting!</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rc <span class="op">=</span> SDL_AudioStreamPut<span class="op">(</span>stream<span class="op">,</span> samples<span class="op">,</span> num_samples <span class="op">*</span> <span class="kw">sizeof</span> <span class="op">(</span>Sint16<span class="op">));</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>rc <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Uhoh, failed to put samples in stream: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> SDL_GetError<span class="op">());</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Whoops, forgot to add a single sample at the end...!</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">//  You can put any amount at once, SDL will buffer</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">//  appropriately, growing the buffer if necessary.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>Sint16 onesample <span class="op">=</span> <span class="dv">22</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>SDL_AudioStreamPut<span class="op">(</span>stream<span class="op">,</span> <span class="op">&amp;</span>onesample<span class="op">,</span> <span class="kw">sizeof</span> <span class="op">(</span>Sint16<span class="op">));</span></span></code></pre></div>
<p>As you add data to the stream, SDL will convert and resample it. You
can ask how much converted data is available:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> avail <span class="op">=</span> SDL_AudioStreamAvailable<span class="op">(</span>stream<span class="op">);</span>  <span class="co">// this is in bytes, not samples!</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>avail <span class="op">&lt;</span> <span class="dv">100</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;m still waiting on </span><span class="sc">%d</span><span class="st"> bytes of data!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">100</span> <span class="op">-</span> avail<span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And when you have enough data to be useful, you can read out samples
in the requested format:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> converted<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">// this is in bytes, not samples!</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> gotten <span class="op">=</span> SDL_AudioStreamGet<span class="op">(</span>stream<span class="op">,</span> converted<span class="op">,</span> <span class="kw">sizeof</span> <span class="op">(</span>converted<span class="op">));</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>gotten <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Uhoh, failed to get converted data: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> SDL_GetError<span class="op">());</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>write_more_samples_to_disk<span class="op">(</span>converted<span class="op">,</span> gotten<span class="op">);</span> <span class="co">/* whatever. */</span></span></code></pre></div>
<p>Of course, you don&#39;t have to read it all at once. This both streams
in <em>and</em> out of a converted buffer, so you can read less than is
available:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> gotten<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> converted<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is in bytes, not samples!</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    gotten <span class="op">=</span> SDL_AudioStreamGet<span class="op">(</span>stream<span class="op">,</span> converted<span class="op">,</span> <span class="kw">sizeof</span> <span class="op">(</span>converted<span class="op">));</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>gotten <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Uhoh, failed to get converted data: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> SDL_GetError<span class="op">());</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// (gotten) might be less than requested in SDL_AudioStreamGet!</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        write_more_samples_to_disk<span class="op">(</span>converted<span class="op">,</span> gotten<span class="op">);</span> <span class="co">/* whatever. */</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>gotten <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>In terms of performance: buffer allocations, conversion, and
resampling happen during stream puts. Getting from the stream is a
little bookkeeping and some memcpy() calls. Plan accordingly.</p>
<p>The one gotcha of this interface: you might notice that you have less
available than you expect (possibly even zero bytes available!). When
resampling, SDL keeps a buffer of padding available so that data sent
through in chunks still resamples smoothly. Rather than try to predict
the future, it just holds onto the first little piece you feed into the
stream, and then starts converting that part after it&#39;s received more
data, holding a tiny bit back each time to keep the stream sounding
smooth.</p>
<p>There are two ways to deal with this: if you&#39;re planning to stream
forever, don&#39;t do anything. Just keep feeding more data as you have it,
and reading more data from the stream as it becomes available, and it&#39;ll
all work out.</p>
<p>If you are simply at the end of the data you want to stream, you can
communicate this to SDL and it will convert any buffered data it&#39;s been
holding onto internally, making it available to be read with <a href="SDL_AudioStreamGet.html" title="wikilink">SDL_AudioStreamGet</a>().</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    SDL_AudioStreamFlush<span class="op">(</span>stream<span class="op">);</span></span></code></pre></div>
<p>Note that if you flush a stream, you can then feed it more data, but
there will likely be gaps in the audio output, as the resampler will use
silence for the padding at the end. You really only want to flush to
finish off a stream and get the last few samples out of it.</p>
<p>If, for whatever reason, you want to throw a stream&#39;s contents away
without reading it, you can:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    SDL_AudioStreamClear<span class="op">(</span>stream<span class="op">);</span></span></code></pre></div>
<p>This will remove any data you&#39;ve put to the stream without reading,
and reset internal state (so the resampler will be expecting a fresh
buffer instead of resampling against data you previously wrote to the
stream). This is useful if you plan to reuse a stream for different
source, or just decided that the current source wasn&#39;t working out;
maybe you&#39;re muting an offensive person on a VoIP app.</p>
<p>When you are done with the stream, you can destroy it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>     SDL_FreeAudioStream<span class="op">(</span>stream<span class="op">);</span></span></code></pre></div>
<p>This frees up internal state and buffers. You don&#39;t have to drain the
stream before freeing it. The <a href="SDL_AudioStream.html" title="wikilink">SDL_AudioStream</a> pointer you&#39;ve been using is
invalid after this call.</p>
<p>That&#39;s all!</p>
</body>
</html>
